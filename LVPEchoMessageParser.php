<?php
use Nuwani \ Bot;

/**
 * LVPEchoHandler module for Nuwani v2
 * 
 * @author Dik Grapendaal <dik@sa-mp.nl>
 */
class LVPEchoMessageParser
{
        /**
         * @var LVPConfiguration
         */
        private $Configuration;

        /**
         * @var LVPCommandHandler
         */
        private $CommandService;

        /**
         * @var LVPCrewHandler
         */
        private $CrewService;

        /**
         * @var LVPIpManager
         */
        private $IpService;

        /**
         * @var LVPIrcService
         */
        private $IrcService;

        /**
         * @var LVPPlayerManager
         */
        private $PlayerService;

        /**
         * @var LVPWelcomeMessage
         */
        private $WelcomeMessageService;

        /**
         * In order to filter Nuwani's output in the echo channel as best as we
         * can, I used something that was called the "shit triggers" in the
         * previous bot. However, I think that's a bit inappropriate, and
         * therefore I'm calling this the Ignore Triggers. These are the
         * triggers we will ignore at all times and thus will not be parsed by
         * this class.
         * 
         * @var array
         */
        private $m_aIgnoreTriggers;
        
        /**
         * 
         * @param LVPConfiguration  $configuration         
         * @param LVPCommandHandler $commandService        
         * @param LVPCrewHandler    $crewService           
         * @param LVPIpManager      $ipService             
         * @param LVPIrcService     $ircService            
         * @param LVPPlayerManager  $playerService         
         * @param LVPWelcomeMessage $welcomeMessageService 
         */
        public function __construct(LVPConfiguration $configuration, LVPCommandHandler $commandService, LVPCrewHandler $crewService, LVPIpManager $ipService, LVPIrcService $ircService, LVPPlayerManager $playerService, LVPWelcomeMessage $welcomeMessageService) {
                $this->Configuration = $configuration;
                $this->CommandService = $commandService;
                $this->CrewService = $crewService;
                $this->IpService = $ipService;
                $this->IrcService = $ircService;
                $this->PlayerService = $playerService;
                $this->WelcomeMessageService = $welcomeMessageService;
            
                $this->m_aIgnoreTriggers = array(
                        '7Online', '4Upload', '6***',
                        '6Matches', '4Error:', '4Notice:'
                );
                
                $this->Configuration->addDirective('parser', 'welcomemsg', true, FILTER_VALIDATE_BOOLEAN);
                $this->Configuration->addDirective('parser', 'reports',    true, FILTER_VALIDATE_BOOLEAN);
        }

        /**
         * What's a parser without a parse method? Exactly, nothing much. So...
         * here it is. This method will happily parse our LVP echo channel
         * message and extract the needed informations. These will then be put 
         * to use in other methods.
         * 
         * @var Bot $pBot The bot which received the message.
         * @var string $sMessage The actual message we're going to parse.
         */
        public function parse (Bot $pBot, $sMessage)
        {
                $aChunks = preg_split ('/\s+/', $sMessage);
                
                switch ($aChunks [0])
                {
                        case '05***':
                        {
                                $this -> handleAdminMessage ($pBot, substr ($sMessage, 7), $aChunks);
                                break;
                        }
                        
                        case '2***':
                        {
                                if ($aChunks [1] == '7Admin' || $aChunks [1] == '7Report')
                                {
                                        $this -> handleCrewChat ($pBot, $aChunks [2], implode (' ', array_slice ($aChunks, 4)), $aChunks);
                                }
                                break;
                        }
                        
                        case '4***':
                        {
                                if ($aChunks [1] == 'Global' && $aChunks [2] == 'Gamemode' && $aChunks [3] == 'Initialization')
                                {
                                        $this -> handleGamemodeInit ();
                                }
                                break;
                        }
                        
                        case '4IP':
                        {
                                $nId = substr ($aChunks [3], 4, -2);
                                $this -> handleIpMessage ($pBot, $nId, $aChunks [2], $aChunks [4], $aChunks);
                                break;
                        }
                }
                
                if (!isset ($aChunks [1]))
                {
                        return ;
                }
                
                switch ($aChunks [1])
                {
                        case '03***':
                        case '3***':
                        {
                                $nId = substr (Func :: stripFormat ($aChunks [0]), 1, -1);
                                if ($aChunks [3] == 'joined')
                                {
                                        $this -> handleJoinGame ($pBot, $nId, $aChunks [2], $aChunks);
                                }
                                else if ($aChunks [3] == 'left')
                                {
                                        $this -> handleLeaveGame ($pBot, $nId, $aChunks [2], substr ($aChunks [6], 1, -3), $aChunks);
                                }
                                else if ($aChunks [4] == 'logged')
                                {
                                        $this -> handleLoggedIn ($pBot, $nId, $aChunks [2], $aChunks);
                                }
                                break;
                        }
                        
                        default:
                        {
                                if (substr ($aChunks [1], 0, 3) == '07' &&
                                    substr ($aChunks [1], -2) == ':')
                                {
                                        $nId       = substr (Util :: stripFormat ($aChunks [0]), 1, -1);
                                        $sNickname = substr (Util :: stripFormat ($aChunks [1]), 0, -1);
                                        
                                        $this -> handleMainChatMessage ($pBot, $nId, $sNickname, implode (' ', array_slice ($aChunks, 2)), $aChunks);
                                }
                                break;
                        }
                }
                
                /* Enable this when going to save the echo logs.
                if (in_array ($aChunks [0], $this -> m_aIgnoreTriggers))
                {
                        return ;
                }
                
                if (count ($aChunks) == count (explode (', ', implode (' ', $aChunks))))
                {
                        // Filter out the !players command.
                        return ;
                }
                
                if (Func :: getPieces ($aChunks, ' ', 0, 3) == 'has been online for' ||
                    Func :: getPieces ($aChunks, ' ', 0, 2) == 'is a player' ||
                    Func :: getPieces ($aChunks, ' ', 0, 4) == 'requested player is not registered')
                {
                        return ;
                }
                */
        }
        
        /**
         * This method will be triggered when a general administrator message
         * came along. It will look for messages such as temporary administrator
         * rights, but also usage of /modlogin.
         * 
         * @param Bot $pBot The bot which received the message.
         * @param string $sMessage The actual admin message.
         * @param array $aChunks The complete message split by spaces.
         */
        private function handleAdminMessage (Bot $pBot, $sMessage, $aChunks)
        {
            /**
             * A crew member logged into their account using /modlogin.
             * 
             * Gamemode:
             * "%s (Id:%d) has logged in as %s (%s) using /modlogin."
             * <Nuwani> *** aok (Id:7) has logged in as cake (administrator) using /modlogin.
             * <Nuwani> 05*** soktaart (Id:13) has logged in as cake (administrator) using /modlogin.
             */
            if (isset ($aChunks [10]) && $aChunks [4] == 'logged' && $aChunks [10] == '/modlogin.')
            {
                if ($aChunks[8] == '(manager)') {
                    $nLevel = LVP::LEVEL_MANAGEMENT;
                }
                else if ($aChunks [8] == '(administrator)') {
                    $nLevel = LVP :: LEVEL_ADMINISTRATOR;
                }
                
                $this -> CrewService -> addModLogin ($aChunks [1], $aChunks [7], $nLevel);
                
                // And done.
                return ;
            }
            
            /**
             * A crew member granted some extra rights to a person ingame.
             * Giving temp rights using a command from IRC returns the same
             * output as when somebody does the same thing ingame. So that's
             * processed in here as well.
             *
             * From IRC:
             * "%s (IRC) has granted temp. admin rights to %s (Id:%d)."
             * 
             * Gamemode:
             * "%s (Id:%d) has granted temp. admin rights to %s (Id:%d)."
             *
             * Unescaped regex:
             * ^([^ ]+) \((?:I[Dd]:\d+|IRC)\) has granted temp\.? ([^ ]+) rights to ([^ ]+) \(I[Dd]:\d+\)\.?$
             */
            if (preg_match('/^([^ ]+) \\((?:I[Dd]:\\d+|IRC)\\) has granted temp\\.? ([^ ]+) rights to ([^ ]+) \\(I[Dd]:\\d+\\)\\.?$/', $sMessage, $matches) > 0) {
                switch ($matches[2]) {
                    case 'admin':
                        $this->CrewService->addTempAdmin($matches[3], $matches[1]);
                        return;
                }
            }

            /**
             * Somebody took some rights from a person ingame. Taking temp
             * rights using a command from IRC returns the same output as
             * when somebody does the same thing ingame. So that's processed
             * in here as well.
             *
             * From IRC:
             * "%s (IRC) has taken admin rights from %s (Id:%d)."
             * 
             * Gamemode:
             * "%s (Id:%d) has taken admin rights from %s (Id:%d)."
             * "%s (Id:%d) has taken their own admin rights."
             *
             * Unescaped regex:
             * ^([^ ]+) \((?:I[Dd]:\d+|IRC)\) has taken (?:their own |)([^ ]+) rights(?: from ([^ ]+) \(I[Dd]:\d+\)|)\.?$
             */
            if (preg_match('/^([^ ]+) \\((?:I[Dd]:\\d+|IRC)\\) has taken (?:their own |)([^ ]+) rights(?: from ([^ ]+) \\(I[Dd]:\\d+\\)|)\\.?$/', $sMessage, $matches) > 0) {
                switch ($matches[2]) {
                    case 'admin':
                        $this->CrewService->removeAdmin(isset($matches[3]) ? $matches[3] : $matches[1]);
                        return;
                }
            }
        }
        
        /**
         * I want the bot to able to respond to commands issued from the ingame
         * crew chat as well. We'll do exactly that, in here.
         * 
         * @param Bot $pBot The bot which received the message.
         * @param string $sNickname The nickname of the person speaking in the crew chat.
         * @param string $sMessage The message the person said.
         * @param array $aChunks The message split by spaces.
         */
        private function handleCrewChat (Bot $pBot, $sNickname, $sMessage, $aChunks)
        {
                $nId = (int) substr ($aChunks [3], 4, -3);
                
                if ($nId == 255 || $this -> CrewService -> isIngameCrew ($sNickname))
                {
                        $aChatChunks = array_slice ($aChunks, 4);
                        $sTrigger    = array_shift ($aChatChunks);
                        
                        if ($sTrigger [0] == '!')
                        {
                                if ($nId != 255)
                                {
                                        $nLevel = $this -> CrewService -> getLevel ($sNickname);
                                }
                                else
                                {
                                        $nLevel = LVP :: LEVEL_ADMINISTRATOR;
                                }
                                
                                $this -> CommandService -> handleCrewChat ($nLevel, $sNickname, $sTrigger, $aChatChunks);
                        }
                }
                else
                {
                        /** The person talking is not crew, maybe a report? **/
                        if (!$this -> PlayerService -> isCrewIngame ())
                        {
                                /** There's no crew ingame either, this must be a report then. **/
                                if ($this -> Configuration -> getDirective ('parser', 'reports'))
                                {
                                        $this -> IrcService -> privmsg ($pBot, LVP :: CREW_CHANNEL,
                                                ModuleBase::COLOUR_ORANGE . '* Report by ' . $sNickname . ' (ID:' . $nId . ')'
                                                . ModuleBase::CLEAR . ': ' . $sMessage);
                                }
                        }
                }
        }
        
        /**
         * This method will be called as soon as the LVP gamemode is restarted.
         * This means that everything that was going on in the server, is no
         * longer going on. So, we need to clean things up.
         */
        private function handleGamemodeInit ()
        {
                $this -> IrcService -> info (null, LVP :: CREW_CHANNEL, 'Everything reset due to gamemode restart.');
                
                $this -> CrewService -> clearIngameCrew ();
                $this -> PlayerService -> clearPlayers ();
        }
        
        /**
         * This method handles the IP address message from Nuwani. It will store
         * the IP and nickname combination together with a date into the
         * database for even less privacy.. err.. more stats.
         * 
         * @param Bot $pBot The bot which received the message.
         * @param integer $nId The ID of the player.
         * @param string $sNickname The person the IP belongs to.
         * @param string $sIp The IP in dotted format.
         * @param array $aChunks The original message in chunks.
         */
        private function handleIpMessage (Bot $pBot, $nId, $sNickname, $sIp, $aChunks)
        {
                $this -> PlayerService -> setPlayerKey ($nId, 'IP', $sIp);
                
                if (defined ('DEBUG_MODE') && DEBUG_MODE)
                {
                        // Don't save IPs when in debug mode.
                        return ;
                }
                
                $bResult = $this -> IpService -> insertIp ($sNickname, $sIp);
                if (!$bResult)
                {
                        $this -> IrcService -> error ($pBot, LVP :: DEBUG_CHANNEL, 'Could not save IP address "' . $sIp . '": Trying again with a new connection...');
                        LVPDatabase :: restart ();
                        
                        $bResult = $this -> IpService -> insertIp ($sNickname, $sIp);
                        if ($bResult)
                        {
                                $this -> IrcService -> success ($pBot, LVP :: DEBUG_CHANNEL, 'Saved IP address "' . $sIp . '".');
                        }
                        else
                        {
                                $this -> IrcService -> error ($pBot, LVP :: DEBUG_CHANNEL, 'Could not save IP address "' . $sIp . '" with nickname "' . $sNickname . '".');
                        }
                }
        }
        
        /**
         * This method gets called as soon someone joins the LVP server. We'll
         * create an LVPPlayer object here for him/her and store the time he/she
         * joined.
         * 
         * @param Bot $pBot The bot which received the message.
         * @param integer $nId The ID of the player.
         * @param string $sNickname The person who joined the game.
         * @param array $aChunks The original message in chunks.
         */
        private function handleJoinGame (Bot $pBot, $nId, $sNickname, $aChunks)
        {
                $this -> PlayerService -> setPlayerKey ($nId, 'Nickname', $sNickname);
                $this -> PlayerService -> setPlayerKey ($nId, 'JoinTime', time ());
        }
        
        /**
         * This method gets called when someone leaves the server. We use this
         * to clean some stuff up. We also save the session time if this player
         * was registered.
         * 
         * @param Bot $pBot The bot which received the message.
         * @param integer $nId The ID of the player.
         * @param string $sNickname The person who left the server.
         * @param string $sReason The reason the connection was closed.
         * @param array $aChunks The original message in chunks.
         */
        private function handleLeaveGame (Bot $pBot, $nId, $sNickname, $sReason, $aChunks)
        {
                $nProfileId = $this -> PlayerService -> getPlayerKey ($nId, 'ProfileID');
                if ($nProfileId > 0)
                {
                        /** Save session time for this registered player. **/
                        $nJoinTime = $this -> PlayerService -> getPlayerKey ($nId, 'JoinTime');
                        $nSessionTime = time () - $nJoinTime;
                        
                        $db = LVPDatabase :: getInstance ();
                        $db -> query (
                                'INSERT INTO samp_ingame_test
                                        (user_id, part_time, session_time)
                                VALUES
                                        (' . $nProfileId . ', NOW(), ' . $nSessionTime . ')');
                }
                
                $this -> CrewService -> removeAdmin ($sNickname);
                $this -> PlayerService -> deletePlayer ($nId);
        }
        
        /**
         * Registered players have the ability to log into their accounts in the
         * LVP server. We store the time they did that so we can see whether
         * they're registered or not. Also because we now know for sure that
         * this player is registered, we'll fetch the profile ID from the
         * database. This is used later on when the player leaves the game, to
         * store his/her session time.
         * 
         * @param Bot $pBot The bot which received the message.
         * @param integer $nId The ID of the player.
         * @param string $sNickname The person who logged in.
         * @param array $aChunks The original message in chunks.
         */
        private function handleLoggedIn (Bot $pBot, $nId, $sNickname, $aChunks)
        {
                $this -> PlayerService -> setPlayerKey ($nId, 'LogInTime', time ());
                
                $nLevel = $this -> CrewService -> getLevel ($sNickname);
                $this -> PlayerService -> setPlayerKey ($nId, 'Level', $nLevel);
                
                $db = $this->Database;
                $pResult = $db -> query (
                        'SELECT u.user_id
                        FROM lvp_mainserver.users_nickname n
                        LEFT JOIN lvp_mainserver.users u ON u.user_id = n.user_id
                        LEFT JOIN lvp_mainserver.users_mutable m ON m.user_id = u.user_id
                        WHERE n.nickname = "' . $db -> real_escape_string ($sNickname) . '"');
                
                if ($pResult !== false && $pResult -> num_rows > 0)
                {
                        list ($nProfileId) = $pResult -> fetch_row ();
                        $this -> PlayerService[$nId] -> fetchInformation ($nProfileId);
                        $pResult -> free ();
                }
                
                if ($this -> Configuration -> getDirective ('parser', 'welcomemsg'))
                {
                        $this -> WelcomeMessageService -> handleWelcomeMessage ($nId, $sNickname, $aChunks);
                }
        }
        
        /**
         * If there's a command in the main chat message, this method will be
         * the one responsible so that the command handler knows about it.
         * 
         * @param Bot $pBot The bot which received the message.
         * @param integer $nId The ID of the player.
         * @param string $sNickname The nickname of the person saying something.
         * @param string $sMessage The message of the player.
         * @param array $aChunks The original message in chunks.
         */
        private function handleMainChatMessage (Bot $pBot, $nId, $sNickname, $sMessage, $aChunks)
        {
                list ($sTrigger, $sParams, $aParams) = Util :: parseMessage ($sMessage);
                $this -> CommandService -> handleMainChat (LVP :: LEVEL_NONE, $sNickname, $sTrigger, $aParams);
        }
}
